/****************************************************************************
 * SurfProcessing
 * Copyright (c) 2014 Brian Y. Chen
 * All rights reserved.
 *
 * This file is part of SurfProcessing
 * 
 * SurfProcessing is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * SurfProcessing is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SurfProcessing.  If not, see <http://www.gnu.org/licenses/>.  
 *
 * File: main.cpp
 *       main methods, execution options
 *
 * Written by 
 *       Brian Y. Chen <chen@lehigh.edu>
 *
 * WWW URL: http://cse.lehigh.edu/~chen/
 * Email: chen@lehigh.edu
 * Documentation can be found here: 
 * http://www.ploscompbiol.org/article/info:doi/10.1371/journal.pcbi.1000881
 *
 ***************************************************************************/


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Implementation for the Main methods for the Geometric Hashing Database search
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void defaultOutput()
{
		printf("\n");
		printf("###################################################################################\n");
		printf("##  SurfProcessing %2.1f Copyright (c) 2014 Brian Y. Chen                          ##\n", VERS_NUM);
		printf("##                                                                               ##\n");
		printf("##  This program comes with ABSOLUTELY NO WARRANTY. This is free software.       ##\n");
		printf("##  You are welcome to redistribute it under the terms of the GNU General        ##\n");
		printf("##  Public License as published by the Free Software Foundation, either          ##\n");
		printf("##  version 3 of the License, or (at your option) any later version.             ##\n");
		printf("##                                                                               ##\n");
		printf("##  Reference: \"VASP: A Volumetric Analysis of Surface Properties                ##\n");
		printf("##  Yields Insights into Protein-Ligand Binding Specificity.\"                    ##\n");
		printf("##  Brian Y. Chen and Barry Honig, PLOS Computational Biology, 2010.             ##\n");
		printf("###################################################################################\n");
		printf("\n");
		printf("Usage:\n");
		printf("\n");
		printf("surfProcessing <command>\n");
		printf("For ease of use, surfaceExtractor will return completed commands for partially entered commands.\n");
		printf("\n");
		printf("surfProcessing -? <command>\n");
		printf("Returns a detailed desciption of the most similar commands.\n");
		printf("\n");
		printf("surfProcessing -fileFormat\n");
		printf("Describes the SURF file format for outside interaction.\n");
		printf("\n");
		printf("#########################################################\n");
		printf("\n");
		exit(0);
}


void errorOutput()
{
		printf("\n");
		printf("===============================================================\n");
		printf("Erroneous Input Detected.  Rerun with no command line arguments\n");
		printf("for usage description and help.\n");
		printf("===============================================================\n");
		printf("\n");
		exit(0);
}

void outputFileFormat()
{
		printf("\n");
		printf("###################################################################################\n");
		printf("##  SurfProcessing %2.1f Copyright (c) 2014 Brian Y. Chen                          ##\n", VERS_NUM);
		printf("##                                                                               ##\n");
		printf("##  This program comes with ABSOLUTELY NO WARRANTY. This is free software.       ##\n");
		printf("##  You are welcome to redistribute it under the terms of the GNU General        ##\n");
		printf("##  Public License as published by the Free Software Foundation, either          ##\n");
		printf("##  version 3 of the License, or (at your option) any later version.             ##\n");
		printf("##                                                                               ##\n");
		printf("##  Reference: \"VASP: A Volumetric Analysis of Surface Properties                ##\n");
		printf("##  Yields Insights into Protein-Ligand Binding Specificity.\"                    ##\n");
		printf("##  Brian Y. Chen and Barry Honig, PLOS Computational Biology, 2010.             ##\n");
		printf("###################################################################################\n");
		printf("\n");
		printf("See documentation describing the SURF format in SURFformat.txt\n");
		printf("\n");
		printf("  SURF FORMAT:\n");
		printf("     -Anywhere in the file, empty lines and line starting with '#' are\n");
		printf("     considered comments, and are ignored.\n");
		printf("     -File has 2 sections: geometry and topology\n");
		printf("     -NO COMMENTS INSIDE EACH SECTION\n");
		printf("\n");
		printf("     The geometry section is always first, and starts with:\n");
		printf("     GEOMETRY: <int>\n");
		printf("     where <int> is the number of points to be specified.\n");
		printf("     then there are <int> lines as follows:\n");
		printf("     <float> <float> <float> <float> <float> <float>\n");
		printf("     which stand for x,y,z, and xnormal, ynormal, znormal.\n");
		printf("\n");
		printf("     The topology section is always second, and starts with:\n");
		printf("     TOPOLOGY: <int>\n");
		printf("     where <int> specifies the number of triangles on the surface\n");
		printf("     Then there are <int> lines as follows:\n");
		printf("     <int> <int> <int>\n");
		printf("     Each int stands for the 3 corners of the triangle\n");
		printf("     and is an index into the array of points provided in the\n");
		printf("     Geometry section.  I.e. the geometry section is indexed\n");
		printf("     starting at zero, and ending at (size-1).\n");
		printf("=========================================================\n");
		exit(0);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////










/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char * surfProbeGen(int m)
{
	char * r = new char[10000];
	if(m==1){sprintf(r, "-surfProbeGen");}
	if(m==2){sprintf(r, "[PDBinput] [SURFoutput] [Radius] [Resolution]");}
	if(m==3){sprintf(r, "---Generates a probe by creating a surface of [radius]-spheres at ecah ligand atom.\n   [PDBinput] Input Ligand atoms (PDB file format) sphere centers.\n   [SURFoutput] Output filename.\n   [radius] Surface will be the union of spheres of this radius\n"); }
	return r;
}
bool surfProbeGenExecution(int argc, char* argv[])
{
	if(argc != 6){ errorOutput(); }
	char * ligFile = argv[2];
	char * outputFile = argv[3];
	double radius = atof(argv[4]);	
	double resolution = atof(argv[5]);	
	SurfaceObject * outputSurf = ProbeGenWrapper(ligFile, radius, resolution);
	generateSURF(outputSurf, NULL, outputFile); 
	return true;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char * pSurfGeneration(int m)
{
	char * r = new char[10000];
	if(m==1){sprintf(r, "-surfPotentialContour");}
	if(m==2){sprintf(r, "[pdbFile] [INSIGHTgrid] [SURFoutput] [contourThreshold] [+/-] [resolution]");}
	if(m==3){sprintf(r, "---Generates a SURF file that represents the shape of the potential contour.\n   [pdbFile] is the input PDB structure.\n   [INSIGHTgrid] is the potential field\n   [SURFoutput] is the name of the output file.\n   [contourThreshold] is the level of charge to compute the countour at.\n   [+/-] causes the output surface to contain the region above/below the threshold.\n   [resolution] is the resolution of the output.\n"); }
	return r;
}
bool pSurfGenerationExecution(int argc, char* argv[])
{
	if(argc != 8 ){ errorOutput(); }
	if(argc == 8){
		int aboveOrBelow = 0;
		if( strcmp(argv[6], "-")==0 ){ aboveOrBelow = -1; }
		if( strcmp(argv[6], "+")==0 ){ aboveOrBelow = 1; }
		if( aboveOrBelow == 0 ){ errorOutput(); exit(1); }
		SurfaceObject * phySurf = generatePhimapSurface( argv[2], argv[3], atof(argv[5]), aboveOrBelow, atof(argv[7]) );
		generateSURF(phySurf, NULL, argv[4]);
	//	delete[](phySurf);
	}

	return true;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char * surveyVolume(int m)
{
	char * r = new char[10000];
	if(m==1){sprintf(r, "-surveyVolume");}
	if(m==2){sprintf(r, "[surfFile]");}
	if(m==3){sprintf(r, "---A fast and reasonably accurate way to compute volume, using the Surveyor's Formula.\n"); }
	return r;
}
bool surveyVolumeExecution(int argc, char* argv[])
{
	if(argc != 3){ errorOutput(); }
	//argv[2] = surfFile
	surveyorsFormulaExecution(argv[2]);
	return true;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
set_t commandCompletion(char * input, bool generateStdOut)
{
	set_t result = alloc_set(SP_MAP);
	int i = 0;	int j = 0;
	int numCommands = 100;
	char ** commands = new char*[numCommands];
	char ** clines = new char*[numCommands];
	for(i = 0; i<numCommands; i++){ commands[i] = new char[100]; }
	for(i = 0; i<numCommands; i++){ clines[i] = new char[1000]; }
	i = 0;

                                                                                                                        	
	/////////////////////////////////////////////////////////////////                                                       	
	////COMMANDS AVAILABLE AT IN ALL COMPILE CONFIGURATIONS                                                                 	
	delete[](commands[i]); delete[](clines[i]);	commands[i] = pSurfGeneration(1);	clines[i] = pSurfGeneration(2);			i++; numCommands = i;
	delete[](commands[i]); delete[](clines[i]);	commands[i] = surfProbeGen(1);	               clines[i] = surfProbeGen(2); 				i++; numCommands = i;
	delete[](commands[i]); delete[](clines[i]);	commands[i] = surveyVolume(1);                    clines[i] = surveyVolume(2);                 i++; numCommands = i;
	/////////////////////////////////////////////////////////////////
	//identify which command is closest
	set_t eliminatedSet = alloc_set(0);
	bool noCommands = false;

	for(i = 0; i<(int)strlen(input); i++){
		for(j = 0; j<numCommands; j++){
			if( (i<(int)strlen(commands[j])) && (input[i]!=commands[j][i]) ){ eliminatedSet = put_set(eliminatedSet, j); }
		}
		if( size_set(eliminatedSet)==numCommands ){ noCommands = true; break; }
	}
	
	//return the set of eligible commands
	if( noCommands ){
		printf("\n");
		printf("ERROR: There are no commands that name-complete from your input. Try something shorter.\n");
		printf("ERROR: Please note that all commands begin with \"-\".\n");
		printf("\n");
		exit(0);
	}
	else{
		if(generateStdOut){ 
			printf("\n");
			printf("----------------------------------------------------------------------\n"); 
			printf("Several commands name-complete from your input; they are listed below:\n"); 
			printf("For more detailed info, type \"[executable] -? <command>\"\n"); 
			printf("----------------------------------------------------------------------\n\n"); 
		}
		int count = 0;
		for(i = 0; i<numCommands; i++){
			if( !contains_set(eliminatedSet, i) ){ count++; result = associate_set(result, size_set(result), commands[i]); }
		}
		if(count > 4){
			for(i = 0; i<numCommands; i++){
				if( !contains_set(eliminatedSet, i) && generateStdOut){ printf(" %s\n", commands[i]);}
			}
			printf("\n");
		}
		else{
			for(i = 0; i<numCommands; i++){
				if( !contains_set(eliminatedSet, i) && generateStdOut){ printf(" %s %s\n", commands[i], clines[i]); }
			}
			printf("\n");
		}
	}
	
	///clean up
	//for(i = 0; i<numCommands; i++){ delete[](commands[i]); }  //we store these in result.  Its only a tiny leak anyway.
	for(i = 0; i<numCommands; i++){ delete[](clines[i]); }
	delete[](commands);
	delete[](clines);
	
	///return the list of integers corresponding to the things we call.
	return result;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////








/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//execution format : [executable name] [cabFile name]
int main(int argc, char* argv[])
{
	time_t seconds = time(NULL);
	srandom(seconds);
//	printf("Random Seed: [%ld]\n", seconds);
	int i = 0;

	/////////////////////////////////////////////////////////////////////////////////PLYtoSURF
	if(argc == 1){ defaultOutput(); }
	if(argc == 2 && (strcmp(argv[1], "-fileFormat") == 0) ){ outputFileFormat(); }	///if these hit, they exit, so we dont need to detect for them later.
	if(argc == 2 && (strcmp(argv[1], "-?") != 0)  ){ commandCompletion(argv[1], true); exit(0); }
	if(argc == 2 && (strcmp(argv[1], "-?") == 0) ){
		printf("%s %s\n%s\n", surfProbeGen(1)                ,      surfProbeGen(2)                ,      surfProbeGen(3)                 );
		printf("%s %s\n%s\n", pSurfGeneration(1)             ,      pSurfGeneration(2)             ,      pSurfGeneration(3)              );
		printf("%s %s\n%s\n", surveyVolume(1)                ,      surveyVolume(2)                ,      surveyVolume(3)                 );
	}
	if(argc == 3 && (strcmp(argv[1], "-?") == 0) ){
		set_t vals = commandCompletion(argv[2], false);
		for(i = 0; i<size_set(vals); i++){
			if(i > 5){ break; }
			char * str = (char *) mapsto_set(vals, i);
			if( strcmp(str, surfProbeGen(1)               )==0 ){ printf("%s %s\n%s\n", surfProbeGen(1)              , surfProbeGen(2)             , surfProbeGen(3)              ); }
			if( strcmp(str, pSurfGeneration(1)            )==0 ){ printf("%s %s\n%s\n", pSurfGeneration(1)           , pSurfGeneration(2)          , pSurfGeneration(3)           ); }
			if( strcmp(str, surveyVolume(1)               )==0 ){ printf("%s %s\n%s\n", surveyVolume(1)              , surveyVolume(2)             , surveyVolume(3)              ); }
		}
		exit(0);
	}
	/////////////////////////////////////////////////////////////////////////////////



	////process the real commands now.
	set_t vals = commandCompletion(argv[1], false);
	if( size_set(vals) != 1 ){ printf("ERROR: The command specified [%s] is not an existing surfaceExtractor command.\n", argv[1]); exit(0); }
	else{
		char * str = (char *) mapsto_set(vals, i);
		if( strcmp(str, surfProbeGen(1)             )==0 ){ surfProbeGenExecution             (argc, argv); }
		if( strcmp(str, pSurfGeneration(1)          )==0 ){ pSurfGenerationExecution          (argc, argv); }
		if( strcmp(str, surveyVolume(1)             )==0 ){ surveyVolumeExecution             (argc, argv); }
	}
	return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


