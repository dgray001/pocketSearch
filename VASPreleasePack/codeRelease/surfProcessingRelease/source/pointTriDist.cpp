/****************************************************************************
 * SurfProcessing
 *   Copyright (c) 2014 Brian Y. Chen
 *
 * This file is part of SurfProcessing
 * 
 * SurfProcessing is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * SurfProcessing is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SurfProcessing.  If not, see <http://www.gnu.org/licenses/>.  
 *
 * This file incorporates work covered by the following copyright
 * and permission notices:
 *
 * Copyright (c) 1998-2014 Geometric Tools, LLC
 *
 * Permission to use, copy, modify, and/or distribute this software
 * for any purpose with or without fee is hereby granted, provided
 * that the above copyright notice and this permission notice appear
 * in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS 
 * OF USE, DATA OR PROFTS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * File: triIntersect.cpp
 *       geometric tests for triangles
 *
 * Written by 
 *       David Eberly
 * Modified by 
 *       Brian Y. Chen
 *
 ***************************************************************************/



#include "pointTriDist.h"










///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The code below is a modified version of the following work by David Eberly, for the Wild Magic geometry library
// It was modified by Brian Chen
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Geometric Tools, LLC
// Copyright (c) 1998-2014
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
//
// File Version: 5.0.1 (2010/10/01)
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
double distanceToTriangle(double * A, double * B, double * C, double * P)
{
	/////////////////////////////////////////////////////////////////////////
	///DEGENERACY CHECK FIRST:///////////////////////////////////////////////
	///deal with degenerate triangles: triangles that are essentially lines or points
	double area = triangleArea(A, B, C);
	if(area == 0){
		///if the triangle is degenerate (i.e. area = 0), then there are two cases.
		//////First, the points could all have distance zero.
		if( (vectorSize(A,B)==0) && (vectorSize(B,C)==0) && (vectorSize(C,A)==0) ){
			return vectorSize(A,P);
		}
		//////Otherwise, the triangle is a segment.
		else{
			double closestSeg = HUGE_VAL;
			double distSeg;
			if(vectorSize(A,B) > 0){
				distSeg = distanceToSegmentFast(A, B, P);
				if(distSeg < closestSeg){ closestSeg = distSeg; }
			}
			if(vectorSize(B,C) > 0){
				distSeg = distanceToSegmentFast(B, C, P);
				if(distSeg < closestSeg){ closestSeg = distSeg; }
			}
			if(vectorSize(C,A) > 0){
				distSeg = distanceToSegmentFast(C, A, P);
				if(distSeg < closestSeg){ closestSeg = distSeg; }
			}
			return closestSeg;
		}
	}
	///DEGENERACY CHECK FIRST:///////////////////////////////////////////////
	///deal with degenerate triangles: triangles that are essentially lines or points
	/////////////////////////////////////////////////////////////////////////

	double result;

//	Vector3<Real> kDiff = m_pkTriangle->V[0] - *m_pkVector;
//	Vector3<Real> kEdge0 = m_pkTriangle->V[1] - m_pkTriangle->V[0];
//	Vector3<Real> kEdge1 = m_pkTriangle->V[2] - m_pkTriangle->V[0];

	double * kDiff  = new double[3];
	kDiff[0] = A[0]-P[0];	kDiff[1] = A[1]-P[1];	kDiff[2] = A[2]-P[2];
	double * kEdge0 = new double[3];
	kEdge0[0] = B[0]-A[0];	kEdge0[1] = B[1]-A[1];	kEdge0[2] = B[2]-A[2];
	double * kEdge1 = new double[3];
	kEdge1[0] = C[0]-A[0];	kEdge1[1] = C[1]-A[1];	kEdge1[2] = C[2]-A[2];

	//Real fA00 = kEdge0.SquaredLength();
	double fA00 = kEdge0[0]*kEdge0[0] + kEdge0[1]*kEdge0[1] + kEdge0[2]*kEdge0[2];
	//Real fA01 = kEdge0.Dot(kEdge1);
	double fA01 = DOT(kEdge0, kEdge1);
	//Real fA11 = kEdge1.SquaredLength();
	double fA11 = kEdge1[0]*kEdge1[0] + kEdge1[1]*kEdge1[1] + kEdge1[2]*kEdge1[2];
	//Real fB0 = kDiff.Dot(kEdge0);
	double fB0 = DOT(kDiff, kEdge0);
	//Real fB1 = kDiff.Dot(kEdge1);
	double fB1 = DOT(kDiff, kEdge1);
	//Real fC = kDiff.SquaredLength();
	double fC = kDiff[0]*kDiff[0] + kDiff[1]*kDiff[1] + kDiff[2]*kDiff[2];
	//Real fDet = Math<Real>::FAbs(fA00*fA11-fA01*fA01);
	double fDet = fabs(fA00*fA11-fA01*fA01);
	//Real fS = fA01*fB1-fA11*fB0;
    double fS = fA01*fB1-fA11*fB0;
	//Real fT = fA01*fB0-fA00*fB1;
    double fT = fA01*fB0-fA00*fB1;
	//Real fSqrDistance;
    double fSqrDistance;

    if (fS + fT <= fDet)
    {
        if (fS < 0.0)
        {
            if (fT < 0.0)  // region 4
            {
                if (fB0 < 0.0)
                {
                    fT = 0.0;
                    if (-fB0 >= fA00)
                    {
                        fS = 1.0;
                        fSqrDistance = fA00+(2.0)*fB0+fC;
                    }
                    else
                    {
                        fS = -fB0/fA00;
                        fSqrDistance = fB0*fS+fC;
                    }
                }
                else
                {
                    fS = 0.0;
                    if (fB1 >= 0.0)
                    {
                        fT = 0.0;
                        fSqrDistance = fC;
                    }
                    else if (-fB1 >= fA11)
                    {
                        fT = 1.0;
                        fSqrDistance = fA11+(2.0)*fB1+fC;
                    }
                    else
                    {
                        fT = -fB1/fA11;
                        fSqrDistance = fB1*fT+fC;
                    }
                }
            }
            else  // region 3
            {
                fS = 0.0;
                if (fB1 >= 0.0)
                {
                    fT = 0.0;
                    fSqrDistance = fC;
                }
                else if (-fB1 >= fA11)
                {
                    fT = 1.0;
                    fSqrDistance = fA11+(2.0)*fB1+fC;
                }
                else
                {
                    fT = -fB1/fA11;
                    fSqrDistance = fB1*fT+fC;
                }
            }
        }
        else if (fT < 0.0)  // region 5
        {
            fT = 0.0;
            if (fB0 >= 0.0)
            {
                fS = 0.0;
                fSqrDistance = fC;
            }
            else if (-fB0 >= fA00)
            {
                fS = 1.0;
                fSqrDistance = fA00+(2.0)*fB0+fC;
            }
            else
            {
                fS = -fB0/fA00;
                fSqrDistance = fB0*fS+fC;
            }
        }
        else  // region 0
        {
            // minimum at interior point
            double fInvDet = (1.0)/fDet;
            fS *= fInvDet;
            fT *= fInvDet;
            fSqrDistance = fS*(fA00*fS+fA01*fT+(2.0)*fB0) + fT*(fA01*fS+fA11*fT+(2.0)*fB1)+fC;
        }
    }
    else
    {
        double fTmp0, fTmp1, fNumer, fDenom;

        if (fS < 0.0)  // region 2
        {
            fTmp0 = fA01 + fB0;
            fTmp1 = fA11 + fB1;
            if (fTmp1 > fTmp0)
            {
                fNumer = fTmp1 - fTmp0;
                fDenom = fA00-2.0*fA01+fA11;
                if (fNumer >= fDenom)
                {
                    fS = 1.0;
                    fT = 0.0;
                    fSqrDistance = fA00+(2.0)*fB0+fC;
                }
                else
                {
                    fS = fNumer/fDenom;
                    fT = 1.0 - fS;
                    fSqrDistance = fS*(fA00*fS+fA01*fT+2.0*fB0) + fT*(fA01*fS+fA11*fT+(2.0)*fB1)+fC;
                }
            }
            else
            {
                fS = 0.0;
                if (fTmp1 <= 0.0)
                {
                    fT = 1.0;
                    fSqrDistance = fA11+(2.0)*fB1+fC;
                }
                else if (fB1 >= 0.0)
                {
                    fT = 0.0;
                    fSqrDistance = fC;
                }
                else
                {
                    fT = -fB1/fA11;
                    fSqrDistance = fB1*fT+fC;
                }
            }
        }
        else if (fT < 0.0)  // region 6
        {
            fTmp0 = fA01 + fB1;
            fTmp1 = fA00 + fB0;
            if (fTmp1 > fTmp0)
            {
                fNumer = fTmp1 - fTmp0;
                fDenom = fA00-(2.0)*fA01+fA11;
                if (fNumer >= fDenom)
                {
                    fT = 1.0;
                    fS = 0.0;
                    fSqrDistance = fA11+(2.0)*fB1+fC;
                }
                else
                {
                    fT = fNumer/fDenom;
                    fS = 1.0 - fT;
                    fSqrDistance = fS*(fA00*fS+fA01*fT+(2.0)*fB0) + fT*(fA01*fS+fA11*fT+(2.0)*fB1)+fC;
                }
            }
            else
            {
                fT = 0.0;
                if (fTmp1 <= 0.0)
                {
                    fS = 1.0;
                    fSqrDistance = fA00+(2.0)*fB0+fC;
                }
                else if (fB0 >= 0.0)
                {
                    fS = 0.0;
                    fSqrDistance = fC;
                }
                else
                {
                    fS = -fB0/fA00;
                    fSqrDistance = fB0*fS+fC;
                }
            }
        }
        else  // region 1
        {
            fNumer = fA11 + fB1 - fA01 - fB0;
            if (fNumer <= 0.0)
            {
                fS = 0.0;
                fT = 1.0;
                fSqrDistance = fA11+(2.0)*fB1+fC;
            }
            else
            {
                fDenom = fA00-2.0*fA01+fA11;
                if (fNumer >= fDenom)
                {
                    fS = 1.0;
                    fT = 0.0;
                    fSqrDistance = fA00+(2.0)*fB0+fC;
                }
                else
                {
                    fS = fNumer/fDenom;
                    fT = 1.0 - fS;
                    fSqrDistance = fS*(fA00*fS+fA01*fT+(2.0)*fB0) + fT*(fA01*fS+fA11*fT+(2.0)*fB1)+fC;
                }
            }
        }
    }

    // account for numerical round-off error
    if (fSqrDistance < 0.0){ fSqrDistance = 0.0; }

//    m_kClosestPoint0 = *m_pkVector;
//    m_kClosestPoint1 = m_pkTriangle->V[0] + fS*kEdge0 + fT*kEdge1;

	delete[](kDiff);
	delete[](kEdge0);
	delete[](kEdge1);

	result = sqrt(fSqrDistance);

	if(area == 0){ printf("ERROR: AREA = 0, DISTANCE: %f\n", result);  }

	return result;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The code above is a modified version of the following work by David Eberly, for the Wild Magic geometry library
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Geometric Tools, LLC
// Copyright (c) 1998-2014
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
//
// File Version: 5.0.1 (2010/10/01)
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////


